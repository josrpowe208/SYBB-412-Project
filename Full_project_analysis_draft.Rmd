---
title: "Cocaine Project Full Analysis"
author:
  affiliation: Case Western Reserve University
  email: jrp208@case.edu
  name: Joseph Powell
date: "`r format(Sys.Date())`"
output:
  html_document:
    code_folding: show
    fig_caption: yes
    highlight: tango
    toc: yes
    toc_float: yes
  html_notebook:
    fig_caption: yes
    highlight: tango
    number_sections: yes
    toc: yes
  pdf_document:
    toc: yes
params:
  dirOfCounts: counts
  dirOfData: data
  dirOfGeo: geo
  dirOfR: R
  dirOfSave: save
  dirOfScriptsDraft: scripts_draft
  dirOfScriptsFinal: scripts_final
  nameOfProject: cocaine RNAseq
  nameOfScript: Full_project_analysis_draft.Rmd
  pathToPreviousGeneScriptSave: save/save.2020-04-25t17_05_47.RDS
  pathToPreviousRNAScriptSave: save/save.2020-04-28t14_25_50.RDS
abstract: This is the script and report for the building of the data into the R environment
  and building an eSet, for the Final project of SYBB 412, where I re-analyze data
  from the paper Gene Network Dysregulation in Dorsolateral Prefrontal Cortex Neurons
  of Humans with Cocaine Use Disorder.
---
```{r setup, include=FALSE}
suppressPackageStartupMessages(library("knitr"))
knitr::opts_knit$set(root.dir = normalizePath(".."))
knitr::opts_chunk$set(warning = FALSE
                     , message     = FALSE
                     , warning     = FALSE
                     , echo        = FALSE
                     , cache       = FALSE
                     , strip.white = TRUE)

```


# Introduction {.tabset}

## Aims

**Objective:** The purpose of this Markdown file is to import RNAseq data from dorsolateral prefrontal cortex neurons of humans with cocaine use disorder and consider what effect integrating long-noncoding RNAs into the analysis has on differential expression and network analysis. 

**A.** To work with through a markdown document that performs import and quality control of an RNAseq expression set. 

**B.** To show some of the characteristics of raw data.

**C.** To show what happens after normalization.

**D.** To work with through a markdown document that creates a model and contrast matrix. 

**E.** To create fits and top table.

**F.** To create a basic heatmap.

--------------------------------------------------------------------------


## Background

Integration of the raw expression of long non-coding RNAs need to be added to the raw expression of genes from this experiment in order to identify any possible downstream impact.


--------------------------------------------------------------------------

## Overall Design

This script will:

1. Read in a saved analysis from an RDS file.

2. Generate individual parts of an Eset (count matrix, pData, fData).

3. Generate a raw Eset.

4. Explore quality control plots.

5. Display plots before normalization

6. Identify sample outliers

7. Normalize samples

8. Display normalized plots

9. Create the normalized eset

10. Look at unsupervised Clustering



--------------------------------------------------------------------------


# Preparation {.tabset}

* Structure of the project folder.
* Libraries used.
* Parameters for the script.

## Structure of Project File

This script is run from within an RStudio project with the following directory structure:

* PROJECT (root of the RStudio project)
  + counts:
  + data: 
  + geo: 
  + R: 
  + save:
  + scripts_draft: 
  + scripts_final: 


--------------------------------------------------------------------------


## Libraries



```{r libraries,  eval=TRUE, echo = TRUE}

# Always Load these libraries
# CRAN
suppressPackageStartupMessages(library(assertthat))
suppressPackageStartupMessages(library(dplyr))

# Bioconductor
suppressPackageStartupMessages(library(Biobase))
suppressPackageStartupMessages(library(limma))
suppressPackageStartupMessages(library(Rsubread))
suppressPackageStartupMessages(library(Rsamtools))
suppressPackageStartupMessages(library(rtracklayer))
suppressPackageStartupMessages(library(impute))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(edgeR))
suppressPackageStartupMessages(library(colorspace))
suppressPackageStartupMessages(library(ggdendro))
suppressPackageStartupMessages(library(dendextend))
suppressPackageStartupMessages(library(genefilter))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(GSVA))
suppressPackageStartupMessages(library(WGCNA))
suppressPackageStartupMessages(library(ReadqPCR))

# Optional

suppressPackageStartupMessages(library(DT))



```


--------------------------------------------------------------------------


## Functions

If you need to create custom functions write them here. Echo is turned on to show functions in report.

* __readInCounts:__ This function reads in the per gene read counts from each individual sample and returns a count matrix.

```{r function1, eval=TRUE, echo=TRUE }


readInCounts <- function(fileList = NULL, 
                         header = TRUE, 
                         platform = 'illuminaBeadTypeFile', 
                         key = 'Illumicode') 
{
  require(impute)
  columnNames <- list()
  
  if (platform == 'illuminaBeadTypeFile') {
    
    # todo: add function validate parameters that verifies files, key
    
    # This is the exported data from the iScan instruments
    
    columnNames[['key']]         <- key    # Name of column of probeIDs
    columnNames[['numBeads']]    <- 'N'    # Number of beads used for calculation
    columnNames[['dev']]         <- 'Dev'  # Deviation as calculated by Illumina software
    
    # Start with first file in the directory
    # Extract the sample names from the filenames.
    # <sampleName>_beadTypeFile.txt
    columnNames[['sampleName']] <- unlist(strsplit(x = basename(fileList[1]),
                                                   split = "_beadTypeFile.txt", perl = TRUE)[1])   
    
    # Read in the first file and set the sample name
    currentFile           <- read.csv(file = fileList[1], header = TRUE, sep = ',' )
    colnames(currentFile) <- c(columnNames$key,columnNames$numBeads, columnNames$sampleName, columnNames$dev)
    currentFile           <- currentFile[, unlist(c(columnNames$key, columnNames$sampleName)) ]
    
    for (i in 2:length(fileList)) {
      
      # Read in the ith file and set the column names
      nextFile                     <- read.csv(file = fileList[i], header = TRUE, sep = ',' )
      columnNames[['sampleName']]  <- unlist(strsplit(x = basename(fileList[i]),
                                                      split = "_beadTypeFile.txt", perl = TRUE)[1])   
      colnames(nextFile) <- c(columnNames$key,columnNames$numBeads, columnNames$sampleName, columnNames$dev)
      nextFile           <- nextFile[, unlist(c(columnNames$key, columnNames$sampleName)) ]
      currentFile        <- base::merge(x = currentFile, 
                                        y = nextFile, 
                                        by = columnNames$key) 
    }
    
  } else {
    
    currentFile <- read.delim(fileList[1], header = TRUE)
    colnames(currentFile) <- c('SYMBOL',basename(fileList[1]))
    
    for (i in 2:length(fileList)) {
      
      nextFile            <- read.delim(fileList[i], header = header)
      colnames(nextFile)  <- c('SYMBOL',basename(fileList[i]))
      currentFile         <- base::merge(currentFile,nextFile,by="SYMBOL") 
    }
    
  }
  
  
  rownames(currentFile)  <- currentFile[,1]
  currentFile            <- currentFile[,-1]
  
  exprs_impute <- suppressMessages(impute::impute.knn(data = as.matrix(currentFile)))
  currentFile <- log(exprs_impute$data,2)
  
  
  as.matrix(currentFile)
}


```


* __collapseProbes:__ This function reduces the number of duplicate identical features.  Keeps the features with the largest variance.

```{r function2, eval=TRUE, echo = TRUE}


collapseProbes <- function (x
                            , method              = 'variance'
                            , topTable            = NULL
                            , colNameOfStat       = NULL
                            , colNameOfGeneSymbol = 'SYMBOL')
{

  # Validate parameters ----------

  if ( !(method %in% list('variance',
                          'logFC','P.Value',
                          'adj.P.Value')) ) {
    stop("Method ", paste(method, "not supported"))
  }

  # Make sure that a topTable is provided
  if (is.data.frame(topTable) ){

    # Check that the metric is one of the columns
    if(!(method %in% list("variance",
                          "logFC", "P.Value",
                          "adj.P.Value")) ) {
      stop("Method ", paste(method, "not supported") )
    }

    # Make sure the column name that has the gene symbol is provided
    if (!(colNameOfGeneSymbol %in% colnames(topTable)) ) {
      stop(paste(colNameOfGeneSymbol, 'must be a column in topTable'))
    }
  }


  # Main Workflow ----------
  if (!is.matrix(x))  {

    # Get Matrix from eset
    mat_exprs <- exprs(x)

  }


  if (method == 'variance') {
    cat("Processing eset using:",method,"\n")

    # Get the Variance Vector
    vec_variance  <- apply(mat_exprs,1,var)

    # get the symbols
    vec_symbol    <- fData(x)[rownames(mat_exprs),
                              colNameOfGeneSymbol]

    # Create a new data frame to cross reference
    df_xref      <- as.data.frame(cbind(mat_exprs, "variance"= vec_variance))

    # Attach the Symbols and the ProbIDs
    df_xref <- cbind(df_xref,"SYMBOL"=vec_symbol,"probeID"=rownames(mat_exprs))

    # order by variance and find the unique SYMBOL list
    df_xref      <- df_xref[order(df_xref[[method]], decreasing=T),]
    uniqueGeneList  <- unique(df_xref[["SYMBOL"]])

    # get first occurance, (highest variance)
    new_matrix    <- df_xref[match(uniqueGeneList,
                                   table = df_xref[["SYMBOL"]]), ]

    # Update the eset
    x <- x[as.vector(new_matrix$probeID),]

    # Return the new eset

    esetToReturn <- x


  }else if (method == 'logFC') {

    cat("Processing eset using:",method,"\n")

    # order by logFC
    topTable <- topTable[order(topTable[[method]], decreasing = TRUE),]

    # subset the df_xref by the rows in the topTable, make sure that:
    #   nrows of df_xref match nrows of topTable
    df_xref <- df_xref[rownames(topTable),]

    # Check that they match
    if(!assertthat::are_equal(rownames(df_xref),rownames(topTable)) ) {
      stop("Matrix rows do not match topTable rows in method=logFC")
    }

    # Combine
    df_xref <- cbind(df_xref,topTable)
    df_xref[[colNameOfGeneSymbol]] <- df_xref[[colNameOfGeneSymbol]]

    # Order by method

    df_xref      <- df_xref[order(df_xref[[method]], decreasing=T),]
    uniqueGeneList  <- unique(df_xref[[colNameOfGeneSymbol]])


    # get first occurance, (highest variance) and create the new matrix
    new_matrix    <- df_xref[match(uniqueGeneList,
                                   table = df_xref[[colNameOfGeneSymbol]]), ]

    mat_exprs <- new_matrix[,colnames(mat_exprs)]
    rownames(mat_exprs) <- as.vector(new_matrix[[colNameOfGeneSymbol]])

    esetToReturn <- x[as.vector(new_matrix$probeID),]
    exprs(esetToReturn) <- as.matrix(mat_exprs)

    new_fData <- new_matrix[,c("SYMBOL","variance","probeID")]
    rownames(new_fData)  <- new_fData[[colNameOfGeneSymbol]]

    fData(esetToReturn) <- new_fData

    assertthat::are_equal(rownames(exprs(esetToReturn)),
                          rownames(fData(esetToReturn)))
  }

  esetToReturn
}


```


* __mapGmt2NamedList:__ This function reads in a GMT file and creates a list. 

```{r functions, eval=TRUE, echo = TRUE}

mapGmt2NamedList <- function(gmtFileName=NULL, type='simple') {
  # This function  takes in a GMT file and creates a named list
  if(type == 'simple') {
    # means name\tgene1\tgene2\t...
    # if default type is simple set to 2
    fieldStart = 2
  } else if (type == 'broad'){
    # name\tURL\t\gene1\t\gene2\
    # if the default type is broad, set to 3
    fieldStart = 3
  } else {
    # if there default is missing
    # Same as broad but 2nd position is not necessarily URL
    fieldStart = 3
  }
  geneSet <- list()
  gmtFile <- readLines(con=gmtFileName)
  gmtFile <- strsplit(gmtFile, '\t')
  
  for (entry in gmtFile) {
    entry <- unlist(entry)
    geneSet[[unlist(entry[1])[1]]] <- entry[fieldStart:length(entry)]
  }
  rm(gmtFile,entry, gmtFileName,type)
  
  geneSet
}



# End of Functions
```



-------------------------------------------------------------------------------


## Initialize script

The init chunk,  take care of setting up the parameters used by the script. 

```{r init, eval=TRUE}


# Always Set Random Seed ! Because 42 is the answer to everything in a random universe.

base::set.seed(42)   

###### Set the parameters for the script #####
# DONT USE 'params', this is used when parameterizing markdown

parameters <- list()   
parameters[['nameOfProject']] <- params$nameOfProject
parameters[['nameOfScript']]  <- params$nameOfScript  



##### Assign Markdown parameters to project parameters #####
  
parameters[['pathTo']] <- list()   # list of lists
parameters$pathTo[['counts']]              <- params$dirOfCounts
parameters$pathTo[['data']]                <- params$dirOfData
parameters$pathTo[['geo']]                 <- params$dirOfGeo
parameters$pathTo[['R']]                   <- params$dirOfR
parameters$pathTo[['save']]                <- file.path(params$dirOfSave, params$nameOfScript)
parameters$pathTo[['pathToScriptsDraft']]  <- params$dirOfScriptsDraft
parameters$pathTo[['pathToScriptsFinal']]  <- params$dirOfScriptsFinal
parameters$pathTo[['pathToPreviousRdataFile']]  <- params$pathToPreviousGeneScriptSave
parameters$pathTo[['pathToPreviousRdataFile2']]  <- params$pathToPreviousRNAScriptSave


########### 

new.folder <- file.path(parameters$pathTo[['save']])

if (! file.exists(new.folder) ) {
  dir.create(path = new.folder,showWarnings = TRUE, recursive = TRUE)
  cat(new.folder, 'created.\n\n')
} else {
  cat(new.folder, 'already exists\n\n')
}


```

## Set Parameters

```{r setParameters,eval=TRUE}

parameters$pathTo

lst_analysis  <- list()     # list of objects we want to save
lst_analysis$nameOfProject <- parameters$nameOfProject
lst_analysis$nameOfScript <- parameters$nameOfScript

lst_esetParts <- list()  # list of objects to make eset

lst_geneSets <- list()  # create a list for geneSets

lst_analysis$DEP <- list()  # add a list for Pathway Analysis

lst_esets.gsva <- list()  # add list for pathway esets

```


-------------------------------------------------------------------------------


# Eset parts {.tabset}


## Creating a count matrix

This was done on the CWRU HPC, and the RDS file was loaded locally into this project directory to complete the analysis. Both gene annotation and lncRNA annotation were run seperately.

```{r featureCounts,eval=FALSE, echo=TRUE}
suppressPackageStartupMessages(library(Rsubread))

setwd("/mnt/pan/courses/sybb412/jrp208/cocaine_project")

lst_esetParts <- list()

sampleTable <- read.delim(file = "/mnt/pan/courses/sybb412/jrp208/PRJNA388174_cocaine/SraRunTable-2.txt", header = TRUE, row.names = 1)

filenames <- list.files(path = '.', pattern = "hisat[[:punct:]]bam$")

# Read in .bam files

fc <- featureCounts(files=filenames, annot.ext="/mnt/pan/courses/sybb412/jrp208/genomes/gencode.v19.annotation.gtf", isGTFAnnotationFile = TRUE, isPairedEnd=TRUE)

colnames(fc$counts) <- sampleTable$Run

lst_esetParts$EsetRaw <- fc
lst_esetParts$sampleTable <- sampleTable


# Create the parameter values

currentTime <- paste(format(Sys.time(), "%Y-%m-%dt%H_%M_%S"))

savePath <- file.path(path = '.',paste('save', currentTime, "RDS", sep=".")) 

# Save the analysis
saveRDS(lst_esetParts, file = savePath )  
lastSaved <- currentTime

rm(currentTime)


sessionInfo()   


#End of create InData object.
```


-------------------------------------------------------------------------------


## pData

```{r readInpData, eval=TRUE, echo=TRUE}

# Import featureCount object from HPC.
pathToRDSGene <- parameters$pathTo$pathToPreviousRdataFile
pathToRDSRNA <- parameters$pathTo$pathToPreviousRdataFile2
lst_esetPartsGene <- readRDS(file = pathToRDSGene)
lst_esetPartsRNA <- readRDS(file = pathToRDSRNA)


# Renaming imported fc portions
names(lst_esetPartsGene) <- c("fc", "pData")
names(lst_esetPartsRNA) <- c("fc", "pData")

# Renaming pData rownames
rownames(lst_esetPartsGene$pData) <- lst_esetPartsGene$pData$Run
rownames(lst_esetPartsRNA$pData) <- lst_esetPartsRNA$pData$Run

# Renaming case_control to be syntactically valid for R
lst_esetPartsGene$pData$case_control <- make.names(lst_esetPartsGene$pData$case_control)
lst_esetPartsRNA$pData$case_control <- make.names(lst_esetPartsRNA$pData$case_control)

# Create a new Column Disorder/Group/Age
lst_esetPartsGene$pData$DGA <- paste(lst_esetPartsGene$pData$case_control
                                 , lst_esetPartsGene$pData$race
                                 , lst_esetPartsGene$pData$age, sep = "_")
lst_esetPartsRNA$pData$DGA <- paste(lst_esetPartsRNA$pData$case_control
                                 , lst_esetPartsRNA$pData$race
                                 , lst_esetPartsRNA$pData$age, sep = "_")

# Create a new Column Disorder/Group
lst_esetPartsGene$pData$DG <- paste(lst_esetPartsGene$pData$case_control
                                 , lst_esetPartsGene$pData$race, sep = "_")
lst_esetPartsRNA$pData$DG <- paste(lst_esetPartsRNA$pData$case_control
                                   , lst_esetPartsRNA$pData$race, sep = "_")


# End of readInpData
```


-------------------------------------------------------------------------------


## fData

```{r prepare_fData, eval=TRUE, echo=TRUE}


# make sure the order of the samples is sequential
lst_esetPartsGene$fc$counts <- lst_esetPartsGene$fc$counts[,order(colnames(lst_esetPartsGene$fc$counts))]
lst_esetPartsRNA$fc$counts <- lst_esetPartsRNA$fc$counts[,order(colnames(lst_esetPartsRNA$fc$counts))]

# Fix the order of the genes and make fData
temp_genes <- rownames(lst_esetPartsGene$fc$counts)
temp_df <- data.frame(t(do.call("cbind", strsplit(temp_genes,"ENSG"))), stringsAsFactors = FALSE) 
colnames(temp_df) <- c('gene_id','geneNumber')
temp_df$gene_id <- paste0(temp_genes)
temp_df$geneNumber <- as.numeric(temp_df$geneNumber)

temp_rna <- rownames(lst_esetPartsRNA$fc$counts)
temp_dfrna <- data.frame(t(do.call("cbind", strsplit(temp_rna,"ENSG"))), stringsAsFactors = FALSE) 
colnames(temp_dfrna) <- c('gene_id','geneNumber')
temp_dfrna$gene_id <- paste0(temp_rna)
temp_dfrna$geneNumber <- as.numeric(temp_dfrna$geneNumber)

# arrange: Order table rows by an expression involving its variables.
temp_df <-   dplyr::arrange(.data = temp_df, gene_id)
rownames(temp_df) <- temp_df$gene_id
lst_esetPartsGene$fData <- temp_df
rm(temp_genes, temp_df)

temp_dfrna <-   dplyr::arrange(.data = temp_dfrna, gene_id)
rownames(temp_dfrna) <- temp_dfrna$gene_id
lst_esetPartsRNA$fData <- temp_dfrna
rm(temp_rna, temp_dfrna)

lst_esetPartsGene$fc$counts <- lst_esetPartsGene$fc$counts[rownames(lst_esetPartsGene$fData),]
lst_esetPartsRNA$fc$counts <- lst_esetPartsRNA$fc$counts[rownames(lst_esetPartsRNA$fData),]

## Read in the gtf file and create expand the fData.
df_gencode <- as.data.frame(import("data/gencode.v19.annotation.gtf"))
temp_fData <- merge(lst_esetPartsGene$fData, df_gencode, by.x = 'gene_id', by.y = 'gene_id', all = FALSE)
temp_fData <- subset(temp_fData, type=='gene')

dfrnacode <- as.data.frame(import("data/gencode.v19.long_noncoding_RNAs.gtf"))
temp_rnafData <- merge(lst_esetPartsRNA$fData, dfrnacode, by.x = 'gene_id', by.y = 'gene_id', all = FALSE)
temp_rnafData <- subset(temp_rnafData, type=='gene')

# %>% is the pipe operator. Passes the data frame to the next function coming along.
# mutate() adds new variables and preserves existing ones; New variables overwrite existing variables of the same name
# arrange: Order table rows by an expression involving its variables.
temp_fData <- temp_fData %>% dplyr::arrange(geneNumber)
temp_rnafData <- temp_rnafData %>% dplyr::arrange(geneNumber)

lst_esetPartsGene$fData <- temp_fData
rownames(lst_esetPartsGene$fData) <- lst_esetPartsGene$fData$gene_id
rm(temp_fData, df_gencode)

lst_esetPartsRNA$fData <- temp_rnafData
rownames(lst_esetPartsRNA$fData) <- lst_esetPartsRNA$fData$gene_id
rm(temp_rnafData, dfrnacode)

# Check that Samples in the pData match the column names in the matrix
if (assertthat::are_equal(rownames(lst_esetPartsGene$pData),colnames(lst_esetPartsGene$fc$counts)) ) {
  cat("sample ids in phenotype data match samples names of exprs matrix.")
}

if (assertthat::are_equal(rownames(lst_esetPartsRNA$pData),colnames(lst_esetPartsRNA$fc$counts)) ) {
  cat("sample ids in phenotype data match samples names of exprs matrix.")
}

# Check that features in the dData match the row names in the matrix
if (assertthat::are_equal(rownames(lst_esetPartsGene$fData),rownames(lst_esetPartsGene$fc$counts)) ) {
  cat("feature ids in the feature data match feature names of exprs matrix.")
}

if (assertthat::are_equal(rownames(lst_esetPartsRNA$fData),rownames(lst_esetPartsRNA$fc$counts)) ) {
  cat("feature ids in the feature data match feature names of exprs matrix.")
}


DT::datatable(head(lst_esetPartsGene$fData[,c('gene_id','seqnames','gene_name','transcript_id')]), class = 'cell-border stripe', rownames = FALSE, filter = 'top'
              , caption = htmltools::tags$caption( 
                style = 'caption-side: bottom; text-align: center;', 
                'Table 3: ', htmltools::em('Feature Data: feature data'))
  )

DT::datatable(head(lst_esetPartsRNA$fData[,c('gene_id','seqnames','gene_name','transcript_id')]), class = 'cell-border stripe', rownames = FALSE, filter = 'top'
              , caption = htmltools::tags$caption( 
                style = 'caption-side: bottom; text-align: center;', 
                'Table 3: ', htmltools::em('Feature Data: feature data'))
  )


#End of prepareEsetParts
```

-------------------------------------------------------------------------------

## The eSet

```{r buildEset, eval=TRUE}

# Combine Eset parts for Gene and RNA (pData)
lst_esetParts$pData <- merge(lst_esetPartsGene$pData, lst_esetPartsRNA$pData)
rownames(lst_esetParts$pData) <- lst_esetParts$pData$Run
# make sure the order of the samples is sequential
lst_esetParts$pData <- lst_esetParts$pData[order(rownames(lst_esetParts$pData)),]

# Combine Eset parts for Gene and RNA (expression matrix)
lst_esetParts$fc$counts <- rbind(lst_esetPartsGene$fc$counts, lst_esetPartsRNA$fc$counts)
lst_esetParts$fc$counts <- lst_esetParts$fc$counts[!duplicated(rownames(lst_esetParts$fc$counts)),]
lst_esetParts$fc$annotation <- rbind(lst_esetPartsGene$fc$annotation, lst_esetPartsRNA$fc$annotation)
lst_esetParts$fc$annotation <- lst_esetParts$fc$annotation[!duplicated(lst_esetParts$fc$annotation$GeneID),]
lst_esetParts$fc$targets <- lst_esetPartsGene$fc$targets
lst_esetParts$fc$statGene <- lst_esetPartsGene$fc$stat
lst_esetParts$fc$statRNA <- lst_esetPartsRNA$fc$stat

# Combine Eset parts for Gene and RNA (fData)
lst_esetParts$fData <- plyr::rbind.fill(lst_esetPartsGene$fData, lst_esetPartsRNA$fData)
# make sure the order of the samples is sequential
lst_esetParts$fData <- lst_esetParts$fData[order(lst_esetParts$fData$gene_id),]
lst_esetParts$fData <- lst_esetParts$fData[!duplicated(lst_esetParts$fData$gene_id),]
rownames(lst_esetParts$fData) <- lst_esetParts$fData$gene_id

# Check that Samples in the pData match the column names in the matrix
if (assertthat::are_equal(rownames(lst_esetParts$pData),colnames(lst_esetParts$fc$counts)) ) {
  cat("sample ids in phenotype data match samples names of exprs matrix.")
}

# Check that features in the dData match the row names in the matrix
if (assertthat::are_equal(rownames(lst_esetParts$fData),rownames(lst_esetParts$fc$counts)) ) {
  cat("feature ids in the feature data match feature names of exprs matrix.")
}


eset.raw <- ExpressionSet(assayData   = as.matrix(lst_esetParts$fc$counts), 
                                                 phenoData   = new("AnnotatedDataFrame",data = lst_esetParts$pData),
                                                 featureData = new("AnnotatedDataFrame", data = lst_esetParts$fData), 
                                                 annotation  = "illuminaHumanv4")


lst_analysis$eset.raw <- eset.raw

eset.raw

# End of buildEset
```


-------------------------------------------------------------------------------


# Preliminary Figures {.tabset}


## Densities (all)

```{r plot1densities, eval=TRUE}

plotDensities(log(exprs(eset.raw),2), legend= FALSE
              , main = 'Raw counts')


pdf(file = file.path(parameters$pathTo$save, 'densitiesRaw.pdf'))
plotDensities(log(exprs(eset.raw),2), legend= FALSE
              , main = 'Raw counts')
dev.off()

# End of plot1densities
```



-------------------------------------------------------------------------------


## MDS plot

```{r plot2MDSall, eval=TRUE}
# plot the mds of Cocaine Dependence Disorder vs. Unaffected.
# 

theFactor <- as.character(pData(eset.raw)$case_control)
theFactorCol <- plyr::revalue(theFactor, c("Cocaine.Dependence"='red', "Unaffected.Control"='green', "Cocaine.Use.Disorder"='blue'))

limma::plotMDS(log(exprs(eset.raw),2) , col = theFactorCol
               , labels = pData(eset.raw)$Run
               , main = paste('MDS - Raw:','Cocaine Status'))
legend(x = "bottomleft"
       , inset = 0.05
       , bty = "n"
       , cex = 0.85
       , legend = c("Cocaine Dependent", "Cocaine Use Disorder", "Unaffected")
       , title = "Cocaine Status"
       , fill = c("red", "blue", "green"))


# save  the plot to file
pdf(file = file.path(parameters$savePath, 'mdsRawCocaineStatus.pdf'))
  limma::plotMDS(log(exprs(eset.raw),2) , col = theFactorCol
               , labels = pData(eset.raw)$Run
               , main = paste('MDS - Raw:','Cocaine Status'))
  legend(x = "bottomleft"
       , inset = 0.05
       , bty = "n"
       , cex = 0.85
       , legend = c("Cocaine Dependent", "Cocaine Use Disorder", "Unaffected")
       , title = "Cocaine Status"
       , fill = c("red", "blue", "green"))
dev.off()




rm(theFactor, theFactorCol)

# End of plot2MDSall
```

-------------------------------------------------------------------------------

## MDS  of Cocaine Dependent Individuals

```{r plot3MDS_Cocaine Dependence, eval=TRUE}
# plot the mds of both cell types.
# 
theTitle <- paste('MDS - Raw:','Cocaine Dependence')
theFactor <- as.character(pData(eset.raw)$case_control)
theFactorCol <- plyr::revalue(theFactor, c("Cocaine.Dependence"='red', "Unaffected.Control"='green', "Cocaine.Use.Disorder"='blue'))

eset.selected <- eset.raw[,pData(eset.raw)$case_control == 'Cocaine.Dependence']

theFactor <- as.character(pData(eset.selected)$race)
theFactorCol <- plyr::revalue(theFactor, c('Black'='blue', 'White'='orange') )


limma::plotMDS(log(exprs(eset.selected),2) , col = theFactorCol
               , labels = pData(eset.selected)$Run
               , main = theTitle)



rm(theTitle, theFactor, theFactorCol, eset.selected)

# End of plot3MDS_CocaineDependent
```

-------------------------------------------------------------------------------

## MDS  of Unaffected Controls

```{r plot4MDS_Unaffected, eval=TRUE}
# plot the mds of both cell types.

theTitle <- paste('MDS - Raw:','Unaffected Control')
theFactor <- as.character(pData(eset.raw)$case_control)
theFactorCol <- plyr::revalue(theFactor, c("Cocaine.Dependence"='red', "Unaffected.Control"='green', "Cocaine.Use.Disorder"='blue'))

eset.selected <- eset.raw[,pData(eset.raw)$case_control == 'Unaffected.Control']

theFactor <- as.character(pData(eset.selected)$race)
theFactorCol <- plyr::revalue(theFactor, c('Black'='blue', 'White'='orange') )


limma::plotMDS(log(exprs(eset.selected),2) , col = theFactorCol
               , labels = pData(eset.selected)$Run
               , main = theTitle )


rm(theTitle, theFactor, theFactorCol)

#End of plot4MDS_Unaffected
```


-------------------------------------------------------------------------------

# Quality Control  

-------------------------------------------------------------------------------

## Esets {.tabset}

### Raw

```{r Raw, eval=TRUE}

lst_analysis$eset.raw

```


### Collapsed

```{r collapseProbes, cache=FALSE, echo=FALSE, eval=TRUE }
## Put the structures that are needed in the space.

selected.eset <- lst_analysis$eset.raw


# Step1 . Collapse the whole eset to  genes to pathways.
# 
eset.collapsed <- collapseProbes(x = selected.eset
                                      , colNameOfGeneSymbol = 'gene_name'
                                      , method = "variance")

fData <- fData(eset.collapsed)

eset.collapsed <- eset.collapsed[!is.na(fData$gene_name),] 

fData <- fData(eset.collapsed)
pData <- pData(eset.collapsed)
mat <- exprs(eset.collapsed)

if(!(assertthat::are_equal(rownames(fData), rownames(mat)) & 
   assertthat::are_equal(rownames(pData), colnames(mat))) ) {
  stop("fData or pData feature names does not match\n")
}

rownames(mat) <- fData(eset.collapsed)$gene_name
rownames(fData) <- fData(eset.collapsed)$gene_name


eset.collapsed.symbol  <- ExpressionSet(assayData   = mat, 
                                                 phenoData   = new("AnnotatedDataFrame",data = pData  ),
                                                 featureData = new("AnnotatedDataFrame", data = fData), 
                                                 annotation  = "illuminaHumanv4")


eset.collapsed.symbol <- eset.collapsed.symbol[!grepl(pattern = "LOC.*"
                                                      , x = rownames(exprs(eset.collapsed.symbol))), ]
eset.collapsed.symbol <- eset.collapsed.symbol[!grepl(pattern = "KIA.*"
                                                      , x = rownames(exprs(eset.collapsed.symbol))), ]
eset.collapsed.symbol <- eset.collapsed.symbol[!grepl(pattern = ".*orf.*"
                                                      , x = rownames(exprs(eset.collapsed.symbol))), ]

lst_analysis$eset.collapsed.symbol <- eset.collapsed.symbol
eset.collapsed.symbol

rm(eset.collapsed, fData, pData, mat)
```


-------------------------------------------------------------------------------

## Plots {.tabset }


### Density Plots (raw)


```{r densityRaw1, eval=TRUE}

# Raw collapsed eset
selected.eset <- lst_analysis$eset.collapsed.symbol

exprs(selected.eset) <- log(exprs(selected.eset),2)


# Plot the densities
plotDensities(selected.eset, legend=FALSE
              , main="All raw data" )


# sort by means then plot
sampleOrder <- sort(colMeans(exprs(selected.eset)))
maxPerBin     <- 8
numBins <- ceiling(length(sampleOrder)/maxPerBin)

for (theBin in seq(1,numBins) ) {
    theList <- seq(from=theBin,to=length(sampleOrder), by=numBins)
    
    # Plot the densities
    plotDensities(selected.eset[,theList], legend='topright'
                  , main = 'raw data')
}



rm(selected.eset, sampleOrder, maxPerBin, numBins, theBin, theList)
# End of density1
```

  
### Boxplots 

#### All

```{r boxplot_SelectedALL, cache=TRUE, eval=TRUE }
selected.eset <- lst_analysis$eset.collapsed.symbol
selected.pData <-  pData(selected.eset)


exprs(selected.eset) <- log(exprs(selected.eset),2)


# Make boxplot
graphics::boxplot(exprs(selected.eset), las=2 )

# End of boxplot
rm(selected.eset )
```

#### Low

```{r boxplot_SelectedLow, cache=TRUE, eval=TRUE }
selected.eset <- lst_analysis$eset.collapsed.symbol
selected.pData <-  pData(selected.eset)


exprs(selected.eset) <- log(exprs(selected.eset),2)


# List of samples to note
lst_lowSamples <- c( 'SRR5616891', 'SRR5616905', 'SRR5616909', 'SRR5616911', 'SRR5616920', 'SRR5616921')

#Take note of the samples that may be outliers
lowSamples <- selected.pData[rownames(selected.pData) %in% 
                       lst_lowSamples,]

selected.eset <- selected.eset[, lst_lowSamples]

#Make boxplot
graphics::boxplot(exprs(selected.eset), las=2 )

# End of boxplot
rm(selected.eset )
```


## MDS plots raw

### Cocaine Dependence

```{r plotMDS1_cocaineStatus, eval=TRUE}

# Get the raw eset
selected.eset <- lst_analysis$eset.collapsed.symbol
selected.pData <- pData(selected.eset)

exprs(selected.eset) <- log(exprs(selected.eset),2)


# Cocaine Status
theFactor <- as.character(pData(selected.eset)$case_control)
theFactorCol <- plyr::revalue(theFactor, c("Cocaine.Dependence"='red', "Unaffected.Control"='green', "Cocaine.Use.Disorder"='blue'))

# Plot the MDS plot
selected.eset.mds <- plotMDS(selected.eset
                             , gene.selection='common'
                             , labels = selected.pData$Run
                             , col = theFactorCol
                             , main = 'Raw data for Cocaine Status' )

rm(selected.eset, selected.pData, selected.eset.mds)
# End of PlotMDS1
```


-------------------------------------------------------------------------------


## Tables {.tabset}

### All Samples

```{r tablesAll, eval=TRUE }
selected.eset <- lst_analysis$eset.collapsed.symbol
selected.pData <-  pData(selected.eset)


allSamples <- selected.pData[rownames(selected.pData),]

lst_colnames <- c('Run', 'Sample_Name', 'Cause_of_death', 'age', 'case_control')

tableToShow <- allSamples[,lst_colnames]

tableToShow <- cbind(tableToShow, meanExp = round(apply(X = exprs(selected.eset), MARGIN = 2, FUN = mean), digits = 4)
                     , mediaExp = round(apply(X = exprs(selected.eset), MARGIN = 2, FUN = median), digits = 4) 
                     )  


DT::datatable(cbind(' ' = '&oplus;', tableToShow ) , escape = -2
              , selection =  list(mode = 'multiple', selected = c(1,2,3), target = 'column')
              , class = 'cell-border stripe', rownames = FALSE, filter = 'top'
              , caption = htmltools::tags$caption( 
                style = 'caption-side: bottom; text-align: center;', 
                'Table 2: ', htmltools::em('Low samples.')) )

# End of tablesAll
rm(selected.eset, selected.pData, tableToShow )
```


### Low Samples

```{r tablesLow, eval=TRUE }
selected.eset <- lst_analysis$eset.collapsed.symbol
selected.pData <-  pData(selected.eset)

# List of samples to note
lst_lowSamples <- c( 'SRR5616891', 'SRR5616905', 'SRR5616909', 'SRR5616911', 'SRR5616920', 'SRR5616921')

#Take note of the samples that may be outliers
lowSamples <- selected.pData[rownames(selected.pData) %in% 
                       lst_lowSamples,]

selected.eset <- selected.eset[, lst_lowSamples]

lst_colnames <- c('Run', 'Sample_Name', 'Cause_of_death', 'age', 'case_control')
tableToShow <- lowSamples[,lst_colnames]

tableToShow <- cbind(tableToShow, meanExp = round(apply(X = exprs(selected.eset), MARGIN = 2, FUN = mean), digits = 4)
                     , mediaExp = round(apply(X = exprs(selected.eset), MARGIN = 2, FUN = median), digits = 4) 
                     )  


DT::datatable(cbind(' ' = '&oplus;', tableToShow ) , escape = -2
              , selection =  list(mode = 'multiple', selected = c(1,2,3), target = 'column')
              , class = 'cell-border stripe', rownames = FALSE, filter = 'top'
              , caption = htmltools::tags$caption( 
                style = 'caption-side: bottom; text-align: center;', 
                'Table 2: ', htmltools::em('Low samples.')) )


# End of tablesLow
rm(selected.eset, selected.pData, lst_lowSamples, tableToShow )
```


### medians < 5

```{r tablesMediansLT5, eval=TRUE }
selected.eset <- lst_analysis$eset.collapsed.symbol

lst_medians <- apply(X = exprs(selected.eset), MARGIN = 2, FUN = median )

lst_medians <- lst_medians[lst_medians<5]

exprs(selected.eset) <- log(exprs(selected.eset),2)


selected.eset <- selected.eset[,names(lst_medians)]



tableToShow <- pData(selected.eset)
tableToShow <- cbind(tableToShow, meanExp = round(apply(X = exprs(selected.eset), MARGIN = 2, FUN = mean), digits = 4)
                     , mediaExp = round(apply(X = exprs(selected.eset), MARGIN = 2, FUN = median), digits = 4) 
                     )  

DT::datatable(cbind(' ' = '&oplus;', tableToShow ) , escape = -2
              , selection =  list(mode = 'multiple', selected = c(1,2,3), target = 'column')
              , class = 'cell-border stripe', rownames = FALSE, filter = 'top'
              , caption = htmltools::tags$caption( 
                style = 'caption-side: bottom; text-align: center;', 
                'Table 2: ', htmltools::em('Low samples.')) )


graphics::boxplot(exprs(selected.eset), las=2 )

# End of tablesMediansLT5
rm(selected.eset, lst_medians)
```


-------------------------------------------------------------------------------


# Normalize and Plot {.tabset}


## Mark outliers

```{r mark_outliers, echo=T, eval=TRUE}


eset.selected <-  lst_analysis$eset.collapsed.symbol


pData.selected   <- pData(eset.selected)
pData.selected.temp   <- pData(eset.selected)
pData.selected.temp[] <- lapply(pData.selected.temp, as.character)

lst_outSamples <- c( 'SRR5616891', 'SRR5616905', 'SRR5616909', 'SRR5616911', 'SRR5616920', 'SRR5616921')

for (theSample in lst_outSamples) {
  pData.selected.temp[pData.selected.temp$Run == theSample,"qcList"]  <- "QC"
}

pData.selected$qcList  <- pData.selected.temp$qcList

pData(eset.selected) <- pData.selected

lst_analysis$eset.qc <- eset.selected

rm(eset.selected, pData.selected)

```


## Normalize

```{r createNormalizedEset, eval=TRUE }

# Get the raw qc data
selected.eset <- lst_analysis$eset.qc


parameters$analysisName <- 'Cocaine Dependence in Males'
subAnalysis             <- 'DGE'
lst_coeficients       <- c('CD', 'UC')


# Create the model to add to the dgeList
group <- as.factor(pData(selected.eset )$case_control)
age <- as.factor(pData(selected.eset )$age)
race <- as.factor(pData(selected.eset )$race)
pData(selected.eset)$case_control <- as.factor(pData(selected.eset )$case_control)
mat_design <- model.matrix(~0+group+age+race)
colnames(mat_design)[1:3] <- levels(pData(selected.eset)$case_control)


contrasts <- makeContrasts(CD = Cocaine.Dependence - Unaffected.Control
                           , UC = (Cocaine.Use.Disorder + Cocaine.Use.Disorder)/2 - Unaffected.Control
                           , levels=mat_design)

# Create the DGElist
dgeList <- DGEList(counts = exprs(selected.eset), group = group)
dgeList.raw <- dgeList

# Remove features that have too many zeros
keep <- edgeR::filterByExpr(dgeList, mat_design, min.count=15)
dgeList <- dgeList[keep,,keep.lib.sizes=FALSE]

# Normalize TMM
dgeList <- edgeR::calcNormFactors(dgeList)

# Save normalized arrays
temp_mat  <- edgeR::cpm(dgeList
                       , normalized.lib.sizes = TRUE
                       , log = TRUE
                       , prior.count = 0.1)

# Create the normalized eset without voom correction
temp_pData <- pData(selected.eset)
temp_fData <- fData(selected.eset)
temp_fData <- temp_fData[rownames(temp_mat),]

temp_mat <- temp_mat[,rownames(temp_pData)]

assertthat::are_equal(rownames(temp_mat), rownames(temp_fData))
assertthat::are_equal(colnames(temp_mat), rownames(temp_pData))

eset.norm.novoom <- Biobase::ExpressionSet(assayData = temp_mat
                       , phenoData = Biobase::AnnotatedDataFrame(temp_pData)
                       , featureData = Biobase::AnnotatedDataFrame(temp_fData)
                       )


# Create the normalized eset WITH voom correction
dgeList.voom <- voom(dgeList, mat_design, plot=TRUE, normalize="quantile")
temp_mat  <- edgeR::cpm(dgeList.voom
                       , normalized.lib.sizes = TRUE
                       , log = TRUE
                       , prior.count = 0.1)

temp_pData <- pData(selected.eset)
temp_fData <- fData(selected.eset)
temp_fData <- temp_fData[rownames(temp_mat),]

temp_mat <- temp_mat[,rownames(temp_pData)]

assertthat::are_equal(rownames(temp_mat), rownames(temp_fData))
assertthat::are_equal(colnames(temp_mat), rownames(temp_pData))

eset.norm.voom <- Biobase::ExpressionSet(assayData = temp_mat
                       , phenoData = Biobase::AnnotatedDataFrame(temp_pData)
                       , featureData = Biobase::AnnotatedDataFrame(temp_fData)
                       )


# make sure that the DGElist is in the same order as the eset.norm
dgeList$counts  <- dgeList$counts[rownames(eset.norm.novoom),]
dgeList.voom$counts  <- dgeList$counts[rownames(eset.norm.voom),]

assertthat::are_equal(rownames(dgeList$counts), rownames(dgeList.voom$counts))

lst_analysis[[subAnalysis]]$eset.raw            <- selected.eset  
lst_analysis[[subAnalysis]]$group               <- group
lst_analysis[[subAnalysis]]$mat_design          <- mat_design
lst_analysis[[subAnalysis]]$contrasts           <- contrasts
lst_analysis[[subAnalysis]]$lst_coeficients     <- lst_coeficients
lst_analysis[[subAnalysis]]$dgeList.raw         <- dgeList.raw
lst_analysis[[subAnalysis]]$dgeList             <- dgeList
lst_analysis[[subAnalysis]]$dgeList.v           <- dgeList.voom
lst_analysis[[subAnalysis]]$eset.norm.novoom    <- eset.norm.novoom 
lst_analysis[[subAnalysis]]$eset.norm.v         <- eset.norm.voom


```


## Density plot

```{r densityNormalized, eval=FALSE}

# Normalized Density Plot
selected.eset <- lst_analysis$DGE$eset.norm.v
plotDensities(log(exprs(selected.eset),2), legend=FALSE
              , main="All raw data" )


rm(selected.eset, sampleOrder, maxPerBin, numBins, theBin, theList)
# End of densityNormalized
```


-------------------------------------------------------------------------------

  
## Boxplot


```{r boxplotNormalized, cache=TRUE, eval=FALSE }
selected.eset <- lst_analysis$DGE$eset.norm.v

# Boxplot normalized
graphics::boxplot(log(exprs(selected.eset),2), las=2 )

# End of boxplotNormalized
rm(selected.eset )
```


-------------------------------------------------------------------------------

# Unsupervised Clustering All {.tabset}

-------------------------------------------------------------------------------

## MDS all Normalized Data

```{r mdsNorm, eval=TRUE}

# Get the raw collapsed eset
thePlotTitle     <- "Normalized final samples"
selected.eset    <- lst_analysis$DGE$eset.norm.v
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData$case_control)

#Plot the MDS

color <- rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))[as.numeric(selected.factor)] 

lst_colors <-  rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))
lst_status <-    levels(selected.factor)


limma::plotMDS(selected.eset, col = alpha(as.character(color), 0.65)
                 , pch = 16, cex=3, gene.selection = "pairwise"
                 , main = thePlotTitle )
legend("topright"
         , inset = 0.05
         , bty = "n"
         , cex = 1.0
         , legend = levels(selected.factor)
         , title = "Cocaine Status"
         , fill = rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))
)



rm(selected.eset, selected.pData, selected.factor, color)
# End of mdsNorm
```

-------------------------------------------------------------------------------

## MostAbundant

```{r mostAbundant1, eval=TRUE }

thePlotTitle = "Normalized final samples"
selected.eset    <- lst_analysis$DGE$eset.norm.v
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData$case_control)

# filter genes
mat <- exprs(selected.eset)
selected.eset <- selected.eset[order(rowSums(mat), decreasing = TRUE),]

selected.eset <- selected.eset[1:500,]

kable(head(exprs(selected.eset[,1:5]), n = 100))


rm(selected.eset, selected.pData, selected.factor)
# End of mostAbundant1
```

Many of the most abundant genes are ribosomal or mitochondrial.

-------------------------------------------------------------------------------


## Dendogram

```{r dendogram1, eval=TRUE }
selected.eset <-  lst_analysis$DGE$eset.norm.v
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData$case_control)

color <- rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))[as.numeric(selected.factor)] 

# do clustering using chaining
dend <- exprs(selected.eset) %>% t %>% scale %>% dist(method = "euclidean") %>%
  hclust(method="average")  %>%
  as.dendrogram

plot(dend)

dend <- dend %>% set("labels", selected.pData$case_control) 
dend <- dend %>% set("labels_col", color )
 
plot(dend)


# End of density2
rm(selected.eset, selected.pData, selected.factor, mat, color,dend, thePlotTitle )

```


-------------------------------------------------------------------------------


## Remove ribosomal genes

```{r removeRibosomeGenes, echo=T, eval=TRUE }

# Get the genesets from KEGG
pathToKegg <- file.path(parameters$pathTo$data
                        ,'c2.cp.kegg.v7.1.symbols.gmt')

lst_geneSets$c2.cp.kegg.v7.1 <-   mapGmt2NamedList(gmtFileName =  pathToKegg
                                        ,type = 'broad')

# Get a list of ribosome genes
genesRibosome <- lst_geneSets$c2.cp.kegg.v71$KEGG_RIBOSOME

# Get the normalized eset
selected.eset <- lst_analysis$DGE$eset.norm.v

# remove the ribosome genes
selected.eset <- selected.eset[!rownames(selected.eset) %in% genesRibosome,]


lst_analysis$DGE$eset.norm.v.noRib <- selected.eset

rm(pathToKegg, genesRibosome, selected.eset)
```


-------------------------------------------------------------------------------

## MDS of Normalized Samples without Ribosomal genes

```{r mdsNormalized2, eval=TRUE}

# Get the normalized no-ribo eset
thePlotTitle     <- "Normalized final samples"
selected.eset    <- lst_analysis$DGE$eset.norm.v.noRib
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData$case_control)

#Plot the MDS

color <- rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))[as.numeric(selected.factor)] 

lst_colors <-  rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))
lst_treatments <-    levels(selected.factor)


limma::plotMDS(selected.eset, col = alpha(as.character(color), 0.65)
                 , pch = 16, cex=3, gene.selection = "common"
                 , main = thePlotTitle )
legend("bottomright"
         , inset = 0.05
         , bty = "n"
         , cex = 1.0
         , legend = levels(selected.factor)
         , title = "Cocaine Status"
         , fill = rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))
)



rm(selected.eset, selected.pData, selected.factor, color)
# End of mdsNormalized2
```


-------------------------------------------------------------------------------
  

## MostAbundant NoRibo

```{r mostAbundant2, eval=TRUE }
thePlotTitle = "Normalized final samples"
selected.eset    <- lst_analysis$DGE$eset.norm.v.noRib
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData$case_control)

# filter genes
mat <- exprs(selected.eset)
selected.eset <- selected.eset[order(rowVars(mat), decreasing = TRUE),]

selected.eset <- selected.eset[1:500,]

kable(head(exprs(selected.eset[,1:5])))
```


-------------------------------------------------------------------------------


## Dendogram NoRibo


```{r dendogram2, eval=TRUE }

color <- rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))[as.numeric(selected.factor)] 

# do clustering using chaining
dend <- exprs(selected.eset) %>% t %>% scale %>% dist(method = "euclidean") %>%
  hclust(method="average")  %>%
  as.dendrogram

plot(dend)

dend <- dend %>% set("labels", selected.pData$case_control) 
dend <- dend %>% set("labels_col", color )
 
plot(dend)


# End of dendogram2
rm(selected.eset, selected.pData, selected.factor, mat, color,dend, thePlotTitle )
```


-------------------------------------------------------------------------------

# Supervised Learning {.tabset}


### The Model

```{r theModel, eval=TRUE}

# Get the eset
selected.eset    <- lst_analysis$DGE$eset.norm.v
selected.pData <- pData(selected.eset)

# Select the column to make the contrasts
selected.group <- 'case_control'
selected.factorLevels <- levels(as.factor(pData(selected.eset)[[selected.group]]))

# Make the desgin matrix
mat_design <- model.matrix(~ 0 +  selected.pData[[selected.group]]) 
colnames(mat_design) <- selected.factorLevels
rownames(mat_design) <- rownames(selected.pData)

# Make the contrast matrix
mat_contrasts <- limma::makeContrasts(CD = Cocaine.Dependence - Unaffected.Control
                                      , UC = (Cocaine.Use.Disorder + Cocaine.Dependence)/2 - Unaffected.Control
                                      , levels = mat_design
                                      )

lst_analysis$DGE$mat_design <- mat_design
lst_analysis$DGE$mat_contrasts  <- mat_contrasts

mat_design

mat_contrasts

rm(selected.eset, selected.pData, selected.group, selected.factorLevels
   , mat_design, mat_contrasts)
# End theModel
```


-------------------------------------------------------------------------------


### Summary Table

```{r fitsForGenes,  eval=TRUE}
  
selected.eset    <- lst_analysis$DGE$eset.norm.v
selected.pValue <- 0.05
selected.pValueMethod <- 'BH'
mat_design    <- lst_analysis$DGE$mat_design
mat_contrasts  <- lst_analysis$DGE$mat_contrasts


lst_analysis$DGE$Fits   <- list()  # Create a list object to store the fits
lst_analysis$DGE$TopTables   <- list()  # Create a list object to store the fits

# create the fits for GENES
fit   <- limma::lmFit(object = exprs(selected.eset), mat_design)
fit2  <- limma::contrasts.fit(fit, mat_contrasts)
fit2  <- limma::eBayes(fit2, robust = FALSE)

# Save the fits
lst_analysis$DGE$Fits$fit  <- fit
lst_analysis$DGE$Fits$fit2 <- fit2

# get the TopTable for the F test
df_topTableF <- limma::topTable(fit = fit2, number = Inf, sort.by = 'none')
df_topTableF <- cbind(SYMBOL = rownames(df_topTableF),df_topTableF)


if (selected.pValueMethod == 'BH') {
  theAdjMethod <- 'BH'
} else if (selected.pValueMethod == 'none') {
  theAdjMethod <- 'none'
}

results <- limma::decideTests(fit2, adjust.method = theAdjMethod
                              , p.value = selected.pValue)

vennDiagram(results)

results <- data.frame(results)
colnames(results) <- paste('R', colnames(results), sep=".")

df_topTableF <- cbind(results, df_topTableF)


# Get the TopTable for Cocaine Dependence vs Unaffected Control
df_topTableCD <- limma::topTable(fit = fit2, coef = 'CD', number = Inf, sort.by = "none")
df_topTableCD <- cbind(SYMBOL = rownames(df_topTableCD),df_topTableCD)
df_topTableCD <- cbind(results, df_topTableCD)


# Get the TopTable for Unaffected Control vs Cocaine Use Disorder
df_topTableUC <- limma::topTable(fit = fit2, coef = 'UC', number = Inf, sort.by = "none")
df_topTableUC <- cbind(SYMBOL = rownames(df_topTableUC),df_topTableUC)
df_topTableUC <- cbind(results, df_topTableUC)


### Recoding colorList into colorList_rec
colorList <- lst_colors[1:3] 
colorList_rec <- colorList
colorList_rec <- factor(colorList_rec)



kable(summary(results) )

lst_analysis$DGE$TopTables$results           <- results
lst_analysis$DGE$TopTables$df_topTableF      <- df_topTableF
lst_analysis$DGE$TopTables$df_topTableCD    <- df_topTableCD
lst_analysis$DGE$TopTables$df_topTableUC    <- df_topTableUC

#
#


rm(selected.eset, selected.pValue, mat_design, mat_contrasts, fit, fit2, df_topTableF, results, df_topTableCD, df_topTableUC)

# End of fitsForGenes
```

-------------------------------------------------------------------------------


### Top Table

```{r TopTable,  eval=T}
  
# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Unaffected.Control', 'Cocaine.Use.Disorder')
thePlotTitle           <- "Comparison of Cocaine Dependent and Unaffected Males"
selected.analysisType  <- 'DGE'
selected.toptable      <- 'df_topTableUC'
selected.numberOfRows <- 50

selected.topTable <- lst_analysis$DGE$TopTables$df_topTableUC
selected.topTable <- selected.topTable[abs(as.numeric(selected.topTable$R.UC)) == 1,]
selected.topTable <- selected.topTable[order(abs(selected.topTable$logFC), decreasing = TRUE),]
  

if (nrow(selected.topTable) >= selected.numberOfRows ) {
  selected.topTable <- selected.topTable[1:selected.numberOfRows, c('R.UC',	'SYMBOL',	'logFC',	'AveExpr',	'P.Value','adj.P.Val'	)]
} 

selected.topTable <- selected.topTable %>% arrange(desc(R.UC), desc(logFC))

selected.topTable[, c('logFC',	'AveExpr',	'P.Value','adj.P.Val'	)] <- round(selected.topTable[, c('logFC',	'AveExpr',	'P.Value','adj.P.Val'	)], digits = 4)

kable(selected.topTable)
# End of fitsForGenes
```

-------------------------------------------------------------------------------


## Top30 Genes 

### Cocaine Use vs Unaffected Controls



```{r UAvsCD_top30genes, eval=TRUE}

# Set the parameters that we want

selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
selected.analysisType  <- 'Genes'
selected.toptable      <- 'df_topTableUC'
selected.numberOfGenes <- 30
selected.scale <- 'row'
thePlotTitle           <- paste("Top", selected.numberOfGenes, " Genes")

#Get the Eset
selected.eset   <- lst_analysis$DGE$eset.norm.v
selected.pData  <- pData(selected.eset)

# only keep the samples that are relevant for the treatment
selected.eset <- selected.eset[,selected.pData[[selected.factor.column]] %in% selected.factor.levels ]
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData[[selected.factor.column]])


# Set the pValue cutoff
selected.pValue <- 0.05

# get the TopTable
selected.topTable <- lst_analysis$DGE$TopTables$df_topTableUC


# select top pathways (maxiumum 30 genes)
selected.topTable <-  selected.topTable[abs(as.numeric(selected.topTable$R.UC)) == 1,]
selected.topTable <- selected.topTable[order(abs(as.numeric(selected.topTable$logFC)), decreasing = TRUE),]

if (nrow(selected.topTable) > selected.numberOfGenes ) {
  selected.topTable <- selected.topTable[1:selected.numberOfGenes,]
} 

# adjust the eset to Match so we can fetch annotations easily
selected.eset <- selected.eset[as.character(selected.topTable$SYMBOL), ] 

mat <- exprs(selected.eset)


## Make the Column and Row annotations 
df_annotations_row <- data.frame(logFC = selected.topTable$logFC)
rownames(df_annotations_row) <- selected.topTable$SYMBOL



# Colours for heatmap
#mat = exprs.pathway #- floor(max(exprs.pathway))
max.value <- quantile(mat, na.rm = T, probs = c(0.05,0.95))
max.value <- abs(max.value)
max.high.value <- max(max.value +1)
max.low.value <- -max.high.value
  
  if (max.high.value > 10 | max.low.value < -10) {
    breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
    breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
    breaks <- c(breaks.low, 0, breaks.high)
    
    rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
    rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
    rampcolors      <- c(rampcolors.low,rampcolors.high)
    
  } else {
    breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
    breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
    breaks      <- c(breaks.low, 0, breaks.high)
    
    rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
    rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
    rampcolors      <- c(rampcolors.low,rampcolors.high)
  }

 
  if (min(selected.topTable$logFC) >= 0 ) {
    # make the colours for the FC
    max.high.value <- max(selected.topTable$logFC) +1
    max.low.value <- 0
    
    if (max.high.value > 10) {
      breaks.high <- seq(0.1, ceiling(max.high.value), by = 0.5)
      breaks <- c( 0, breaks.high)
      
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- c(rampcolors.low,rampcolors.high)
      
    } else {
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
      breaks      <- c(0, breaks.high)
      
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- rampcolors.high
    }  
  } else if (max(selected.topTable$logFC) < 0) {
        # make the colours for the FC
    max.high.value <- 0
    max.low.value <- min(selected.topTable$logFC) -1
    
    if (max.low.value < -10) {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.5)
      breaks <- c(breaks.low, 0)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolorsFC      <- rampcolors.low
      
    } else {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
      breaks      <- c(breaks.low, 0)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolorsFC      <- rampcolors.low
    } 
  } else {
     # make the colours for the FC
    matFC <- selected.topTable$logFC
    max.value <- quantile(matFC, na.rm = T, probs = c(0.05,0.95))
    max.value <- abs(max.value)
    max.high.value <- max(max.value +1)
    max.low.value <- -max.high.value
    
    if (max.high.value > 10 | max.low.value < -10) {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.5)
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.5)
      breaks <- c(breaks.low, 0, breaks.high)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- c(rampcolors.low,rampcolors.high)
      
    } else {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
      breaks      <- c(breaks.low, 0, breaks.high)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- c(rampcolors.low,rampcolors.high)
    }
  }
   
      

  
# Change the colour scale to singular

ann_colors = list(logFC   = rampcolorsFC
                  , pcCFSElow = colorRampPalette(c('#ffffff', '#006400' ))(11)
                  , pcDivided = colorRampPalette(c('#ffffff', '#00449B' ))(11)
                  , proliferationIdx = colorRampPalette(c('#ffffff', '#006400' ))(11)
                  #, divisionIdx = colorRampPalette(c('#ffffff', '#00449B' ))(11)
                  #, pcTx2medInhibit = colorRampPalette(c('#ffffff', '#006400' ))(11)
)



pheatmap(mat
         , main = thePlotTitle
         , scale=selected.scale
         , color=rampcolors
         , border_color='grey'
         , cellheight = 9
         , cellwidth =  9
         , fontsize = 7
         , cluster_cols=TRUE
         , cluster_rows=TRUE
         , treeheight_row = 10
         , treeheight_col = 10
         # breaks = breaks
         , labels_col = selected.pData$treatment
         , annotation_row = df_annotations_row
         #, annotation_col = df_annotations_col
         #, annotation_legend = TRUE
         , annotation_colors = ann_colors
         )

rm(selected.eset, selected.pData, selected.pValue, selected.topTable
   , mat, matFC, df_annotations_row, df_annotations_col
   , max.value, max.high.value, max.low.value, breaks.low, breaks.low, breaks
   , rampcolors.low, rampcolors.high, rampcolors, rampcolorsFC, ann_colors)

# End of UAvsCD_top30genes
```


-------------------------------------------------------------------------------


# Pathway analysis of Cocaine Use vs Unaffected Control


## Analyse Hallmark 

First we will look at the Hallmark geneSet. The Hallmark dataset is a good 

```{r hallmark, eval=TRUE}

# Set the filename and the name of the eset
selected.geneSet.file <- 'h.all.v7.1.symbols.gmt'
selected.geneSet.name <- 'h.all' 


# Get the eset
selected.eset <- lst_analysis$DGE$eset.norm.v

# get the genesets for Hallmark
pathToHallmark      <- file.path(parameters$pathTo$data
                        , selected.geneSet.file )

lst_geneSets[[selected.geneSet.name ]]  <-   mapGmt2NamedList(gmtFileName =  pathToHallmark
                                        , type = 'broad')

exprs(selected.eset)[(is.na(exprs(selected.eset)))]<-0

selected.eset <- genefilter::varFilter(selected.eset, var.func=IQR, var.cutoff=0.50, filterByQuantile=TRUE)


# Convert the expression to Signal to activity
eset.gsva <- GSVA::gsva(expr = selected.eset,
                        gset.idx.list = lst_geneSets[[selected.geneSet.name]],
                        parallel.sz =  4,
                        method = 'gsva',
                        verbose = FALSE)

lst_esets.gsva[[selected.geneSet.name]] <- eset.gsva

lst_analysis$DEP$esets <- lst_esets.gsva

rm(selected.geneSet.file, selected.geneSet.name, selected.eset, pathToHallmark
   , eset.gsva)
```




### Unsupervised {.tabset}

#### MDS
```{r hallmark_mds, eval=TRUE, as.ist=TRUE}

# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
thePlotTitle = "Hallmark Pathway MDS for Cocaine Use vs. Unaffected Controls"
selected.geneSet.name <- 'h.all' 

# Get the eSet
selected.eset    <- lst_analysis$DEP$esets[[selected.geneSet.name]]
selected.pData   <- pData(selected.eset)

# only keep the samples that are relecant for the groupShort
selected.eset <- selected.eset[,selected.pData[[selected.factor.column]] %in% selected.factor.levels ]
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData[[selected.factor.column]])


#Plot the MDS

lst_colors <-  rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))
colorList <- lst_colors[1:3] 
color <- colorList[as.numeric(selected.factor)]


limma::plotMDS(selected.eset, col = alpha(as.character(color), 0.65)
                 , pch = 16, cex=3, gene.selection = "pairwise"
                 , main = thePlotTitle )
legend(x = "topright"
         , inset = 0.05
         , bty = "n"
         , cex = 1.0
         , legend = levels(selected.factor)
         , title = "Cocaine Status"
         , fill = rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))
)


rm(selected.factor.column, selected.factor.levels, thePlotTitle, selected.geneSet.name
   , selected.eset, selected.pData, selected.factor
   , lst_colors, colorList)

# End of hallmark_mds
```



-------------------------------------------------------------------------------


#### MostAbundant

```{r hallmark_mostAbundant, eval=TRUE }

# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder')
thePlotTitle = "Most Abundant Hallmark Pathways in Cocaine Dependent vs. Unaffected Control Males"
selected.geneSet.name <- 'h.all' 

# Get the eSet
selected.eset    <- lst_analysis$DEP$esets[[selected.geneSet.name]]
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData[[selected.factor.column]])


# filter features
mat <- exprs(selected.eset)
selected.eset <- selected.eset[order(rowVars(mat), decreasing = TRUE),]

if (nrow(exprs(selected.eset) >=10) ) {
  selected.eset <- selected.eset[1:20,]
}


kable(exprs(selected.eset[,1:6]), n = 50)


# No cleanup -  continues

# End of hallmark_mostAbundant
```



-------------------------------------------------------------------------------


#### Dendogram

```{r hallmark_dendogram, eval=TRUE}

color <- rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))[as.numeric(selected.factor)] 

# do clustering using chaining
dend <- exprs(selected.eset) %>% t %>% scale %>% dist(method = "euclidean") %>%
  hclust(method="complete")  %>%
  as.dendrogram

plot(dend)

dend <- dend %>% set("labels", selected.pData$Run) 
dend <- dend %>% set("labels_col", color )
 
plot(dend)


rm(selected.factor.column, selected.factor.levels, thePlotTitle, selected.geneSet.name
   , selected.eset, selected.pData, selected.pData, mat)
# End of hallmark_dendogram
```


-------------------------------------------------------------------------------

### Supervised {.tabset}


-------------------------------------------------------------------------------

#### Summary of Fits

```{r hallmark_fits,  eval=TRUE}
  
# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
thePlotTitle = "Model for Hallmark Pathways in Cocaine Dependent vs. Unaffected Control Males"
selected.geneSet.name <- 'h.all' 
selected.analysisType <- 'DEP'
selected.pValue <- 0.05
selected.pValueMethod <- 'none'

selected.eset   <- lst_analysis[[selected.analysisType]]$esets[[selected.geneSet.name]]

mat_design    <- lst_analysis$DGE$mat_design
mat_contrasts  <- lst_analysis$DGE$mat_contrasts




# create the fits for GENES
fit   <- limma::lmFit(object = exprs(selected.eset), mat_design )
fit2  <- limma::contrasts.fit(fit, mat_contrasts)
fit2  <- limma::eBayes(fit2, robust = TRUE)

# Save the fits
lst_analysis[[selected.analysisType]]$Fits$fit  <- fit
lst_analysis[[selected.analysisType]]$Fits$fit2 <- fit2

# get the TopTable for the F test
df_topTableF <- limma::topTable(fit = fit2, number = Inf, sort.by = "none")
df_topTableF <- cbind(SYMBOL = rownames(df_topTableF),df_topTableF)


if (selected.pValueMethod == 'BH') {
  theAdjMethod <- 'BH'
} else if (selected.pValueMethod == 'none') {
  theAdjMethod <- 'none'
}

results <- limma::decideTests(fit2, adjust.method = theAdjMethod
                              , p.value = selected.pValue)

df_topTableF <- cbind(results, df_topTableF)


# Get the TopTable for only Cocaine Dependence vs. Unaffected Control
df_topTableCD <- limma::topTable(fit = fit2, coef = 'CD', number = Inf, sort.by = "none")
df_topTableCD <- cbind(SYMBOL = rownames(df_topTableCD),df_topTableCD)
df_topTableCD <- cbind(results, df_topTableCD)


# Get the TopTable for all Cocaine use vs. Unaffected Control
df_topTableUC <- limma::topTable(fit = fit2, coef = 'UC', number = Inf, sort.by = "none")
df_topTableUC <- cbind(SYMBOL = rownames(df_topTableUC),df_topTableUC)
df_topTableUC <- cbind(results, df_topTableUC)

kable(summary(results) )

lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]]$results           <- results
lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]]$df_topTableF      <- df_topTableF
lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]]$df_topTableCD    <- df_topTableCD
lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]]$df_topTableUC    <- df_topTableUC





rm(selected.eset, selected.pValue, mat_design, mat_contrasts, fit, fit2
   , df_topTableF, results, df_topTableCD, df_topTableUC)

# End of hallmark_fits
```


-------------------------------------------------------------------------------

#### TopTable

```{r hallmark_topTable,eval=TRUE}

# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
thePlotTitle           <- "Cocaine Use vs. Unaffected Control Males"
selected.geneSet.name  <- 'h.all' 
selected.analysisType  <- 'DEP'
selected.toptable      <- 'df_topTableCD'

selected.topTable <- lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]][[selected.toptable]]
selected.topTable <- selected.topTable[abs(as.numeric(selected.topTable$CD)) == 1,]
selected.topTable <- selected.topTable %>% arrange(desc(CD), desc(logFC))
  

if (nrow(selected.topTable) >= 50 ) {
  selected.topTable <- selected.topTable[1:50, c('CD',	'SYMBOL',	'logFC',	'AveExpr',	'P.Value','adj.P.Val'	)]
} 

selected.topTable[, c('logFC',	'AveExpr',	'P.Value','adj.P.Val'	)] <- round(selected.topTable[, c('logFC',	'AveExpr',	'P.Value','adj.P.Val'	)], digits = 4)

kable(selected.topTable)
```



#### Top Pathways 

```{r hallmark_topFeatures, eval=TRUE}

# Set the parameters that we want
thePlotTitle           <- "Top Pathways"
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
selected.geneSet.name  <- 'h.all' 
selected.analysisType  <- 'DEP'
selected.toptable      <- 'df_topTableCD'

#Get the Eset 
selected.eset   <- lst_analysis[[selected.analysisType]]$esets[[selected.geneSet.name]]
selected.pData  <- pData(selected.eset)



# only keep the samples that are relecant for the groupShort
selected.eset <- selected.eset[,selected.pData[[selected.factor.column]] %in% selected.factor.levels ]
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData[[selected.factor.column]])


# Set the pValue cutoff
selected.pValue <- 0.05 

# get the TopTable
selected.topTable <- lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]][[selected.toptable]]
selected.topTable <- cbind(SYMBOL = rownames(selected.topTable), selected.topTable)


# select top pathways (maxiumum 20 pathways)
selected.topTable <-  selected.topTable[abs(selected.topTable$CD) == 1,]
selected.topTable <- selected.topTable[ order(abs(selected.topTable$logFC), decreasing = TRUE) ,]

if (nrow(selected.topTable) > 20 ) {
  selected.topTable <- selected.topTable[1:20,]
} 

# adjust the eset to Match so we can fetch annotations easily
selected.eset <- selected.eset[as.character(selected.topTable$SYMBOL), ] 

mat <- exprs(selected.eset)


## Make the Column and Row annotations 
df_annotations_row <- data.frame(logFC = selected.topTable$logFC)
rownames(df_annotations_row) <- selected.topTable$SYMBOL



# Colours for heatmap
#mat = exprs.pathway #- floor(max(exprs.pathway))
max.value <- quantile(mat, na.rm = T, probs = c(0.05,0.95))
max.value <- abs(max.value)
max.high.value <- max(max.value +1)
max.low.value <- -max.high.value
  
  if (max.high.value > 10 | max.low.value < -10) {
    breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
    breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
    breaks <- c(breaks.low, 0, breaks.high)
    
    rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
    rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
    rampcolors      <- c(rampcolors.low,rampcolors.high)
    
  } else {
    breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
    breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
    breaks      <- c(breaks.low, 0, breaks.high)
    
    rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
    rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
    rampcolors      <- c(rampcolors.low,rampcolors.high)
  }

 
  if (min(selected.topTable$logFC) >= 0 ) {
    # make the colours for the FC
    max.high.value <- max(selected.topTable$logFC) +1
    max.low.value <- 0
    
    if (max.high.value > 10) {
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.5)
      breaks <- c( 0, breaks.high)
      
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- c(rampcolors.low,rampcolors.high)
      
    } else {
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
      breaks      <- c(0, breaks.high)
      
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- rampcolors.high
    }  
  } else if (max(selected.topTable$logFC) < 0) {
        # make the colours for the FC
    max.high.value <- 0
    max.low.value <- min(selected.topTable$logFC) -1
    
    if (max.low.value < -10) {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.5)
      breaks <- c(breaks.low, 0)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolorsFC      <- rampcolors.low
      
    } else {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
      breaks      <- c(breaks.low, 0)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolorsFC      <- rampcolors.low
    } 
  } else {
     # make the colours for the FC
    matFC <- selected.topTable$logFC
    max.value <- quantile(matFC, na.rm = T, probs = c(0.05,0.95))
    max.value <- abs(max.value)
    max.high.value <- max(max.value +1)
    max.low.value <- -max.high.value
    
    if (max.high.value > 10 | max.low.value < -10) {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.5)
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.5)
      breaks <- c(breaks.low, 0, breaks.high)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- c(rampcolors.low,rampcolors.high)
      
    } else {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
      breaks      <- c(breaks.low, 0, breaks.high)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- c(rampcolors.low,rampcolors.high)
    }
  }
   
      

  
# Change the colour scale to singular

ann_colors = list(logFC   = rampcolorsFC
                  , pcCFSElow = colorRampPalette(c('#ffffff', '#006400' ))(11)
                  , pcDivided = colorRampPalette(c('#ffffff', '#00449B' ))(11)
                  , proliferationIdx = colorRampPalette(c('#ffffff', '#006400' ))(11)
                  #, divisionIdx = colorRampPalette(c('#ffffff', '#00449B' ))(11)
                  #, pcTx2medInhibit = colorRampPalette(c('#ffffff', '#006400' ))(11)
)



pheatmap(mat
         , main = thePlotTitle
         , scale='row'
         , color=rampcolors
         , border_color='grey'
         , cellheight = 9
         , cellwidth =  9
         , fontsize = 7
         , cluster_cols=TRUE
         , cluster_rows=TRUE
         , treeheight_row = 10
         , treeheight_col = 10
         # breaks = breaks
         , labels_col = selected.pData$groupShort
         , annotation_row = df_annotations_row
         #, annotation_col = df_annotations_col
         #, annotation_legend = TRUE
         , annotation_colors = ann_colors
         )

rm(selected.eset, selected.pData, selected.pValue, selected.topTable
   , mat, matFC, df_annotations_row, df_annotations_col
   , max.value, max.high.value, max.low.value, breaks.low, breaks.low, breaks
   , rampcolors.low, rampcolors.high, rampcolors, rampcolorsFC, ann_colors)

# End of hallmark_topfeatures
```

-------------------------------------------------------------------------------

## Analyse KEGG 

Second we will look at the KEGG geneSet. 

```{r kegg, eval=TRUE}

# Set the filename and the name of the eset
selected.geneSet.file <- 'c2.cp.kegg.v7.1.symbols.gmt'
selected.geneSet.name <- 'c2.cp.kegg.v7.1' 


# Get the eset
selected.eset <- lst_analysis$DGE$eset.norm.v

# get the genesets for Hallmark
pathToKegg      <- file.path(parameters$pathTo$data
                        , selected.geneSet.file )

lst_geneSets[[selected.geneSet.name ]]  <-   mapGmt2NamedList(gmtFileName =  pathToKegg
                                        , type = 'broad')

exprs(selected.eset)[(is.na(exprs(selected.eset)))]<-0

selected.eset <- genefilter::varFilter(selected.eset, var.func=IQR, var.cutoff=0.50, filterByQuantile=TRUE)


# Convert the expression to Signal to activity
eset.gsva <- GSVA::gsva(expr = selected.eset,
                        gset.idx.list = lst_geneSets[[selected.geneSet.name]],
                        parallel.sz =  4,
                        method = 'gsva',
                        verbose = FALSE)

lst_esets.gsva[[selected.geneSet.name]] <- eset.gsva

lst_analysis$DEP$esets <- lst_esets.gsva

rm(selected.geneSet.file, selected.geneSet.name, selected.eset, pathToKegg
   , eset.gsva)
```


### Unsupervised {.tabset}

#### MDS
```{r kegg_mds, eval=TRUE, as.ist=TRUE}

# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
thePlotTitle = "Hallmark Pathway MDS for Cocaine Use vs. Unaffected Controls"
selected.geneSet.name <- 'c2.cp.kegg.v7.1' 

# Get the eSet
selected.eset    <- lst_analysis$DEP$esets[[selected.geneSet.name]]
selected.pData   <- pData(selected.eset)

# only keep the samples that are relecant for the groupShort
selected.eset <- selected.eset[,selected.pData[[selected.factor.column]] %in% selected.factor.levels ]
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData[[selected.factor.column]])


#Plot the MDS

lst_colors <-  rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))
colorList <- lst_colors[1:3] 
color <- colorList[as.numeric(selected.factor)]


limma::plotMDS(selected.eset, col = alpha(as.character(color), 0.65)
                 , pch = 16, cex=3, gene.selection = "pairwise"
                 , main = thePlotTitle )
legend(x = "topright"
         , inset = 0.05
         , bty = "n"
         , cex = 1.0
         , legend = levels(selected.factor)
         , title = "Cocaine Status"
         , fill = rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))
)


rm(selected.factor.column, selected.factor.levels, thePlotTitle, selected.geneSet.name
   , selected.eset, selected.pData, selected.factor
   , lst_colors, colorList)

# End of kegg_mds
```



-------------------------------------------------------------------------------


#### MostAbundant

```{r kegg_mostAbundant, eval=TRUE }

# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder')
thePlotTitle = "Most Abundant KEGG Pathways in Cocaine Dependent vs. Unaffected Control Males"
selected.geneSet.name <- 'c2.cp.kegg.v7.1' 

# Get the eSet
selected.eset    <- lst_analysis$DEP$esets[[selected.geneSet.name]]
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData[[selected.factor.column]])


# filter features
mat <- exprs(selected.eset)
selected.eset <- selected.eset[order(rowVars(mat), decreasing = TRUE),]

if (nrow(exprs(selected.eset) >=10) ) {
  selected.eset <- selected.eset[1:20,]
}


kable(exprs(selected.eset[,1:6]), n = 50)


# No cleanup -  continues

# End of kegg_mostAbundant
```



-------------------------------------------------------------------------------


#### Dendogram

```{r kegg_dendogram, eval=TRUE}

color <- rev(rainbow_hcl(length(levels(as.factor(selected.factor)))))[as.numeric(selected.factor)] 

# do clustering using chaining
dend <- exprs(selected.eset) %>% t %>% scale %>% dist(method = "euclidean") %>%
  hclust(method="complete")  %>%
  as.dendrogram

plot(dend)

dend <- dend %>% set("labels", selected.pData$Run) 
dend <- dend %>% set("labels_col", color )
 
plot(dend)


rm(selected.factor.column, selected.factor.levels, thePlotTitle, selected.geneSet.name
   , selected.eset, selected.pData, selected.pData, mat)
# End of kegg_dendogram
```


-------------------------------------------------------------------------------

### Supervised {.tabset}


-------------------------------------------------------------------------------

#### Summary of Fits

```{r kegg_fits,  eval=TRUE}
  
# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
thePlotTitle = "Model for KEGG Pathways in Cocaine Dependent vs. Unaffected Control Males"
selected.geneSet.name <- 'c2.cp.kegg.v7.1' 
selected.analysisType <- 'DEP'
selected.pValue <- 0.05
selected.pValueMethod <- 'none'

selected.eset   <- lst_analysis[[selected.analysisType]]$esets[[selected.geneSet.name]]

mat_design    <- lst_analysis$DGE$mat_design
mat_contrasts  <- lst_analysis$DGE$mat_contrasts




# create the fits for GENES
fit   <- limma::lmFit(object = exprs(selected.eset), mat_design )
fit2  <- limma::contrasts.fit(fit, mat_contrasts)
fit2  <- limma::eBayes(fit2, robust = TRUE)

# Save the fits
lst_analysis[[selected.analysisType]]$Fits$fit  <- fit
lst_analysis[[selected.analysisType]]$Fits$fit2 <- fit2

# get the TopTable for the F test
df_topTableF <- limma::topTable(fit = fit2, number = Inf, sort.by = "none")
df_topTableF <- cbind(SYMBOL = rownames(df_topTableF),df_topTableF)


if (selected.pValueMethod == 'BH') {
  theAdjMethod <- 'BH'
} else if (selected.pValueMethod == 'none') {
  theAdjMethod <- 'none'
}

results <- limma::decideTests(fit2, adjust.method = theAdjMethod
                              , p.value = selected.pValue)

df_topTableF <- cbind(results, df_topTableF)


# Get the TopTable for only Cocaine Dependence vs. Unaffected Control
df_topTableCD <- limma::topTable(fit = fit2, coef = 'CD', number = Inf, sort.by = "none")
df_topTableCD <- cbind(SYMBOL = rownames(df_topTableCD),df_topTableCD)
df_topTableCD <- cbind(results, df_topTableCD)


# Get the TopTable for all Cocaine use vs. Unaffected Control
df_topTableUC <- limma::topTable(fit = fit2, coef = 'UC', number = Inf, sort.by = "none")
df_topTableUC <- cbind(SYMBOL = rownames(df_topTableUC),df_topTableUC)
df_topTableUC <- cbind(results, df_topTableUC)

kable(summary(results) )

lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]]$results           <- results
lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]]$df_topTableF      <- df_topTableF
lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]]$df_topTableCD    <- df_topTableCD
lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]]$df_topTableUC    <- df_topTableUC





rm(selected.eset, selected.pValue, mat_design, mat_contrasts, fit, fit2
   , df_topTableF, results, df_topTableCD, df_topTableUC)

# End of kegg_fits
```


-------------------------------------------------------------------------------

#### TopTable

```{r kegg_topTable,eval=TRUE}

# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
thePlotTitle           <- "Cocaine Use vs. Unaffected Control Males"
selected.geneSet.name  <- 'c2.cp.kegg.v7.1' 
selected.analysisType  <- 'DEP'
selected.toptable      <- 'df_topTableCD'

selected.topTable <- lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]][[selected.toptable]]
selected.topTable <- selected.topTable[abs(as.numeric(selected.topTable$CD)) == 1,]
selected.topTable <- selected.topTable %>% arrange(desc(CD), desc(logFC))
  

if (nrow(selected.topTable) >= 50 ) {
  selected.topTable <- selected.topTable[1:50, c('CD',	'SYMBOL',	'logFC',	'AveExpr',	'P.Value','adj.P.Val'	)]
} 

selected.topTable[, c('logFC',	'AveExpr',	'P.Value','adj.P.Val'	)] <- round(selected.topTable[, c('logFC',	'AveExpr',	'P.Value','adj.P.Val'	)], digits = 4)

kable(selected.topTable)
```



#### Top Pathways 

```{r kegg_topFeatures, eval=TRUE}

# Set the parameters that we want
thePlotTitle           <- "Top Pathways"
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
selected.geneSet.name  <- 'c2.cp.kegg.v7.1' 
selected.analysisType  <- 'DEP'
selected.toptable      <- 'df_topTableCD'

#Get the Eset 
selected.eset   <- lst_analysis[[selected.analysisType]]$esets[[selected.geneSet.name]]
selected.pData  <- pData(selected.eset)



# only keep the samples that are relecant for the groupShort
selected.eset <- selected.eset[,selected.pData[[selected.factor.column]] %in% selected.factor.levels ]
selected.pData   <- pData(selected.eset)
selected.factor  <- as.factor(selected.pData[[selected.factor.column]])


# Set the pValue cutoff
selected.pValue <- 0.05 

# get the TopTable
selected.topTable <- lst_analysis[[selected.analysisType]]$TopTables[[selected.geneSet.name]][[selected.toptable]]
selected.topTable <- cbind(SYMBOL = rownames(selected.topTable), selected.topTable)


# select top pathways (maxiumum 20 pathways)
selected.topTable <-  selected.topTable[abs(selected.topTable$CD) == 1,]
selected.topTable <- selected.topTable[ order(abs(selected.topTable$logFC), decreasing = TRUE) ,]

if (nrow(selected.topTable) > 20 ) {
  selected.topTable <- selected.topTable[1:20,]
} 

# adjust the eset to Match so we can fetch annotations easily
selected.eset <- selected.eset[as.character(selected.topTable$SYMBOL), ] 

mat <- exprs(selected.eset)


## Make the Column and Row annotations 
df_annotations_row <- data.frame(logFC = selected.topTable$logFC)
rownames(df_annotations_row) <- selected.topTable$SYMBOL



# Colours for heatmap
#mat = exprs.pathway #- floor(max(exprs.pathway))
max.value <- quantile(mat, na.rm = T, probs = c(0.05,0.95))
max.value <- abs(max.value)
max.high.value <- max(max.value +1)
max.low.value <- -max.high.value
  
  if (max.high.value > 10 | max.low.value < -10) {
    breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
    breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
    breaks <- c(breaks.low, 0, breaks.high)
    
    rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
    rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
    rampcolors      <- c(rampcolors.low,rampcolors.high)
    
  } else {
    breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
    breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
    breaks      <- c(breaks.low, 0, breaks.high)
    
    rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
    rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
    rampcolors      <- c(rampcolors.low,rampcolors.high)
  }

 
  if (min(selected.topTable$logFC) >= 0 ) {
    # make the colours for the FC
    max.high.value <- max(selected.topTable$logFC) +1
    max.low.value <- 0
    
    if (max.high.value > 10) {
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.5)
      breaks <- c( 0, breaks.high)
      
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- c(rampcolors.low,rampcolors.high)
      
    } else {
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
      breaks      <- c(0, breaks.high)
      
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- rampcolors.high
    }  
  } else if (max(selected.topTable$logFC) < 0) {
        # make the colours for the FC
    max.high.value <- 0
    max.low.value <- min(selected.topTable$logFC) -1
    
    if (max.low.value < -10) {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.5)
      breaks <- c(breaks.low, 0)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolorsFC      <- rampcolors.low
      
    } else {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
      breaks      <- c(breaks.low, 0)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolorsFC      <- rampcolors.low
    } 
  } else {
     # make the colours for the FC
    matFC <- selected.topTable$logFC
    max.value <- quantile(matFC, na.rm = T, probs = c(0.05,0.95))
    max.value <- abs(max.value)
    max.high.value <- max(max.value +1)
    max.low.value <- -max.high.value
    
    if (max.high.value > 10 | max.low.value < -10) {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.5)
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.5)
      breaks <- c(breaks.low, 0, breaks.high)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- c(rampcolors.low,rampcolors.high)
      
    } else {
      breaks.low  <- seq(-ceiling(max.high.value), -0.1, by=0.1)
      breaks.high <- seq(0.1, ceiling(max.high.value), by=0.1)
      breaks      <- c(breaks.low, 0, breaks.high)
      
      rampcolors.low  <- colorRampPalette(c('#0000FF','#0088FF','#00DDFF','#FFFFFF'))(length(breaks.low))
      rampcolors.high <- colorRampPalette(c('#FFFFFF', '#FFDD00', '#FF8800','#FF0000'))(length(breaks.high))
      rampcolorsFC      <- c(rampcolors.low,rampcolors.high)
    }
  }
   
      

  
# Change the colour scale to singular

ann_colors = list(logFC   = rampcolorsFC
                  , pcCFSElow = colorRampPalette(c('#ffffff', '#006400' ))(11)
                  , pcDivided = colorRampPalette(c('#ffffff', '#00449B' ))(11)
                  , proliferationIdx = colorRampPalette(c('#ffffff', '#006400' ))(11)
                  #, divisionIdx = colorRampPalette(c('#ffffff', '#00449B' ))(11)
                  #, pcTx2medInhibit = colorRampPalette(c('#ffffff', '#006400' ))(11)
)



pheatmap(mat
         , main = thePlotTitle
         , scale='row'
         , color=rampcolors
         , border_color='grey'
         , cellheight = 8
         , cellwidth =  8
         , fontsize = 6
         , cluster_cols=TRUE
         , cluster_rows=TRUE
         , treeheight_row = 9
         , treeheight_col = 9
         # breaks = breaks
         , labels_col = selected.pData$groupShort
         , annotation_row = df_annotations_row
         #, annotation_col = df_annotations_col
         #, annotation_legend = TRUE
         , annotation_colors = ann_colors
         )

rm(selected.eset, selected.pData, selected.pValue, selected.topTable
   , mat, matFC, df_annotations_row, df_annotations_col
   , max.value, max.high.value, max.low.value, breaks.low, breaks.low, breaks
   , rampcolors.low, rampcolors.high, rampcolors, rampcolorsFC, ann_colors)

# End of kegg_topfeatures
```


-------------------------------------------------------------------------------

# Gene Co-expression Network Analysis


-------------------------------------------------------------------------------


### Analysis with voom {.tabset}


#### Network construction

```{r GCEConstruction, echo=TRUE, eval=TRUE}

# Set the parameters that we want
selected.factor.column <- 'case_control'
selected.factor.levels <- c('Cocaine.Dependence','Cocaine.Use.Disorder', 'Unaffected.Control')
selected.geneSet.name  <- 'eset.norm.v' 
selected.analysisType  <- 'DGE'


# Get the eset
selected.eset <-  lst_analysis[[selected.analysisType]][[selected.geneSet.name]]
mat <- exprs(selected.eset)

# Set soft threshold powers
powers <- c(c(1:10), seq(from = 12, to = 50, by = 2))

# Call the network topology analysis function from WGCNA
sft = pickSoftThreshold(mat, powerVector = powers, verbose = 5)


# End of GCEConstruction
```


-------------------------------------------------------------------------------

#### Network Topology of soft-thresholding powers

```{r STPowerPlot1, echo=TRUE, eval=TRUE}

# Scale-free topology fit index as a function of the soft-thresholding power
sizeGrWindow(9, 5)
par(mfrow = c(1, 2))
cex1 = 0.9


plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2]
     , xlab = "Soft Threshold (power)"
     , ylab = "Scale Free Topology Model Fit, signed R^2"
     , type = "n"
     , main = paste("Scale Independence")
     , rep = "best")
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2]
     , labels = powers
     , cex = cex1
     , col = "red")
abline(h=0.90, col="red")


plot(sft$fitIndices[,1], sft$fitIndices[,5]
     , xlab = "Soft Threshold (power)"
     , ylab = "Mean Connectivity"
     , type = "n"
     , main = paste("Mean Connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5]
     , labels = powers
     , cex = cex1
     , col ="red")


# End of STPowerPlot1
```


-------------------------------------------------------------------------------

#### Topological Overlap Matrix Construction

```{r TOMConstruction, echo=TRUE, eval=TRUE}

# Set soft power threshold and calculate adjacency matrix
softPower <- 40
adj_mat <- adjacency(mat, power = softPower)

# Create TOM from adjacency matrix
TO_mat <- TOMsimilarity(adj_mat)
dissTO_mat <- 1-TO_mat


```


#### Gene Clustering using TOM

```{r geneClusterTOM, echo=TRUE, eval=TRUE}

# Call heirarchical clustering function
geneTree <- hclust(as.dist(dissTO_mat), method = "average")

# Plot Clustering Tree
sizeGrWindow(12,9)
plot(geneTree, xlab = "", sub = ""
       , main = "Gene Clustering of TOM-base dissimilarity"
       , labels = FALSE
       , hang = 0.04)


# Set module size  and identification
minModuleSize <- 5
dynamicMods <- cutreeDynamic(dendro = geneTree, distM = dissTO_mat
                             , deepSplit = 2
                             , pamRespectsDendro = FALSE
                             , minClusterSize = minModuleSize)

dynamicColors <- labels2colors(dynamicMods)

table(dynamicMods)

table(dynamicColors)


# Plot resulting clustering tree (dendogram)

sizeGrWindow(12, 9)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut"
                      , dendroLabels = FALSE
                      , hang = 0.03
                      , addGuide = TRUE
                      , guideHang = 0.05
                      , main = "Gene Dendogram and module colors")


# End of geneClusterTOM
```


-------------------------------------------------------------------------------

#### Merging highly similar expression profiles.

Since the Dynamic Tree Cut only identified 3 modules in the above analysis, and with the high beta value necessary for this analysis to even happen, the merging of module is presented to prove that the blue and turqoise will merge into one module, which indicates a confounding covariate not accounted for in the previous analysis.

```{r moduleMerge, echo=TRUE, eval=TRUE}

# Calculate eigengenes
MElist <- moduleEigengenes(mat, colors = dynamicColors)
MEs <- MElist$eigengenes

# Calculate dissimilarity of module eigengenes
MEdiss <- 1-cor(MEs, use = 'pairwise.complete.obs')

# Cluster module eigengenes
METree <- hclust(as.dist(MEdiss), method = "average")

# Plot of results
sizeGrWindow(7, 6)
plot(METree, main = "Clustering of Eigengenes"
     , xlab = "", sub = "")
MEdissThres <- 0.25
abline(h=MEdissThres, col = "red")

# Merge close modules
modulesMerged <- mergeCloseModules(mat, dynamicColors, cutHeight = MEdissThres, verbose = 3)
mergedColors <- modulesMerged$colors
mergedMEs <- modulesMerged$newMEs

# Plot of results
sizeGrWindow(7, 6)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors)
                      , c("Dynamic Tree Cut", "Merged Dynamic")
                      , dendroLabels = FALSE, hang = 0.03
                      , addGuide = TRUE, guideHang = 0.05)

# End of module Merge
```




**THE END**

-------------------------------------------------------------------------------

## SAVE PROJECT


```{r BuildProjectTree, eval=TRUE }

lst_analysis$name <- parameters$nameOfScript
lst_analysis$parameters <- parameters
lst_analysis$eset.raw   <- eset.raw

#End of BuildProjectTree
```


# Saving project

```{r SaveProjectTree, eval=TRUE }

# Create the parameter values

currentTime <- paste(format(Sys.time(), "%Y-%m-%dt%H_%M_%S"))

savePath <- file.path(parameters$pathTo$save,paste('save', currentTime, "RDS", sep=".")) 

# Save the analysis
saveRDS(lst_analysis, file = savePath )  
lastSaved <- currentTime

rm(currentTime)
```



```{r sessionInfo, eval=TRUE }

sessionInfo()   

```

